
    Приложение [MyComoxWS] необходимо для работы с данными, хранящимися в БД, куда они поступают
с датчиков на моторах, а также для отображения этих данных в виде значений и графиков на странице.
При этом WS означает, что для получения данных на веб-странице используется WebSocket.

    Приложение включает в себя следующие составляющие:
    1. БД [mycomoxdb], которая хранит информацию о:
        - моторах с уникальными номерами,
        - датчиках, установленных на моторах (название, единицы измерения),
        - значениями датчиков (timelapse, мотор, датчик, значение),
        - пользователях (имя, фамилия, логин, хэш пароля, роль)
    2. Непосредственно серверная сторона (набор контроллеров, моделей, репозиториев, сервисов и security)
    3. Frontend:
        - home_page (страница логина),
        - testdb_admin (страница для админа, позволяет редактировать данные в БД),
        - testdb_user (страница пользователя, позволяет только просматривать данные)
    4. Security (обеспечение безопасного доступа к ресурсам сервера, аутентификация,
                 авторизация пользователей, защита от CORS и CSRF-атак)

    Порядок работы следующий: пользователь заходит на страницу логина, вводит логин и пароль, а затем
приложение отдает ему страницу в соответствии с ролью - либо страницу юзера, либо админа, либо суперадмина.
Суперадмин может быть добавлен в БД только вручную, его не видно с списке пользователей на странице.
    Суперадмин может манипулировать данными: добавлять и удалять моторы, пользователей, назначать им роли
(админ или юзер), а также он может изменять критическое значение для каждого из датчиков, но не может
создавать новые датчики или удалять их, так как в данной версии приложения не предусмотрено динамическое
добавление на страницу новых блоков с графиками, а также новых строк в блоки с моторами.
    Админ может все, что и суперадмин, за исключением добавления и удаления пользователей.
    Юзер может только просматривать значения и графики, изменять данные в БД он не может.
    При загрузке страницы инициируется подключение по протоколу Websocket.
    Логика использования WebSocket состоит в следующем. Websocket — протокол, который позволяет устанавливать
двустороннюю связь между клиентом и сервером. Переключение на Websocket происходит после специального http-запроса
от клиента. На сервере находится конечная точка, куда клиенты отправляют запрос на подключение, и брокер
сообщений, который обрабатывает сообщения. В данном приложении при запуске сервера запускается и брокер
сообщений, а также функция, которая раз в секунду опрашивает БД, забирает нужные данные и отправляет их
в нужный topic (тему). При загрузке страницы пользователя происходит подключение к брокеру, а также подписка
на конкретные топики (темы), откуда клиент может получать нужные сообщения с данными. Таким образом, клиенту
не нужно самому отправлять запросы на получение данных от сервера, достаточно просто подключиться на нужную
тему, а брокер сам отправит сообщение. Благодаря этому удается уйти от следующих проблем:
    - если клиентов слишком много, и каждый из них раз в секунду отправляет запросы на сервер,
      поступает слишком много сообщений как на сам сервер, так и на сервер БД, что не лучшим образом
      сказывается на производительности, а в данном случае к БД обращается только сервер раз в секунду,
      а уже затем отправляет сообщение всем подписанным на брокер клиентам,
    - как минимум Chrome блокирует выполнение функций по таймеру на странице, если она неактивна,
      таким образом, если мы ушли со страницы с графиками, то какие-то из данных мы просто можем
      не получить и не увидеть, а эти значения могут быть для нас критичными, необходимо не пропустить
      ни одного значения от датчика. Вебсокет позволяет решить эту проблему. Будут обработаны все данные,
      даже если страница не активна.


    Далее по конкретным частям приложения:

    1. Сервер

    Представляет из себя набор контроллеров [TildaControllerDB], которые используют сервисы для получения
необходимых обработанных данных, а те в свою очередь используют репозитории для получения сырых данных.
    Таким образом, образуется цепочка [Repository -> Service -> Controller -> Model(page)/JSON Data].
    В зависимости от контроллера он может являться обычным контроллером, который отдает страницы,
либо REST-контроллером, который возвращает данные в виде JSON.
    GET-запросы просто отдают данные, POST-запросы принимают данные со страницы, которая отправляет их
либо в виде формы, либо в виде JSON (все зависит от настроек ajax-запроса на странице). Если данные
пришли в виде формы, их удобно сразу вытаскивать из запроса в виде объекта из папки [forms]. Spring делает
это автоматически, нужно лишь указать объект нужного класса в параметрах метода.
    Со страницы на сервер поступает запрос, вызывается нужный контроллер, который затем по цепочке вызывает
необходимые сервисы. Те обращаются к Jpa-репозиториям для запроса к БД. Запрос может быть в том числе и в
стандартном SQL-виде (nativeQuery) с перечислением необходимых переменных и добавлением их в сам запрос.

    Логика работы Websocket следующая.
    Аннотация [@EnableWebSocketMessageBroker] включает Websocket-сервер. Обратите внимание, мы реализуем
интерфейс [WebSocketMessageBrokerConfigurer] и переопределяем два из его default-методов.
    В первом методе [registerStompEndpoints()] мы регистрируем конечную точку [/ws], которую клиенты будут
использовать, чтобы подключиться к нашему Websocket-серверу. SockJS — для браузеров, которые не поддерживают
Websocket.
    Обратите внимание на Stomp в названии метода.  STOMP — это Simple Text Oriented Messaging Protocol.
Это протокол обмена сообщениями, задающий формат и правила обмена.
    Зачем нужен Stomp? Дело в том, что сам по себе WebSocket не дает таких вещей (более высокого уровня),
как отправка сообщений пользователям, подписанным на тему, или отправка сообщений конкретному пользователю.
    Во втором методе [configureMessageBroker()] мы настраиваем брокер сообщений, который будет использоваться
для направления сообщений от одного клиента к другому.
    В первой строке мы говорим, что сообщения, чей адрес начинается с [/app], должны быть направлены в методы,
занимающиеся обработкой сообщений. Имеются в виду методы, аннотированные [@MessageMapping], которые в данном
приложении не используются.
    Во второй строке мы говорим, что сообщения, чей адрес начинается с  [/topic], должны быть направлены
в брокер сообщений. Брокер перенаправляет сообщения всем клиентам, подписанным на тему.
    На сервере запускается функция [publishMessage], которая раз в секунду опрашивает БД, а затем отправляет
все данные клиентам, подписанным на [/topic/public]. После опроса БД сервер анализирует временные отметки
для значений датчиков, сопоставляя их со текущим временем сервера. Здесь важно, что если на самом сервере
время отстает или спешит по сравнению с тем временем, которое учитывалось при сохранении значения датчика
в БД, то сервер посчитает данные с датчиков не актуальными, и отображение данных будет нарушено.
    Сопоставление временных меток происходит следующим образом: если полученный ts из бд равен текущей секунде
или секунде ранее, то сохраняем текущее значение датчика. Сравнение идет с двумя последними секундами, а не только
с последней по следующей причине: наш таймер может забрать значение из бд немного раньше, чем его добавит туда
датчик на устройстве, а это значит, что данный ts будет в бд, но чуть позже, и если мы сравним текущий ts с
последней секундой, мы его не увидим. То есть, сервер расценит данную ситуацию как то, что датчик не отправил
значение, поэтому мы должны проверить данное значение в следующей итерации. Таким образом, мы точно можем быть
уверены, что датчик перестал отправлять значения, если разница в ts составляет более 1 секунды.
    Принцип работы обработчика запроса на [/last_values] следующая: происходит вызов функции
[valueService.getLastVals], в которую передаются временной интервал, мотор и датчик. Функция работает по
следующей схеме:
    - берем текущее время, округляем до секунд,
    - находим время [delta] секунд назад,
    - делаем запрос к БД, достаем все значения в данном диапазоне (если они есть),
    - создаем из значений временную мапу со значениями вида {"ts":"value"},
    - пробегаем циклом по всему временному диапазону и забивая вспомогательную мапу значениями
      по принципу: если текущее значение ts из цикла есть в мапе значений из БД, то
      добавляем {"ts": ts, "value": value}, если нет, то {"ts": ts, "value": 0},
    - добавляем мапу в массив, очищаем ее и идем дальше по циклу, массив нужен для того,
      чтобы в нем мапы шли в соответствии с порядком добавления, то есть по очереди, в таком же
      порядке происходит считывание на странице - цикл просто пробегает по массиву и вытаскивает
      ts и value, а потом просто отрисовывает значения.


    2. Frontend

    Есть смысл сразу рассмотреть страницу [testdb_superadmin], так как она содержит в себе весь возможный
функционал.
    Все начинается с загрузки страницы, где после подгрузки всех блоков и элементов, вызывается
[window.onload], где происходит следующее:
    - get-запрос на [/me], где в ответ либо получаем значение переменной [login], либо разлогиниваемся.
        Переменная [login] будет сверяться со значением, которое пришло по вебсокету с топика
        [/topic/logout/**], и если будет совпадение, то происходит разлогинивание. Таким образом,
        сигналом через вебсокет сервер дает команду разлогиниться всем пользователям с данным логином.
    - get-запрос на [/motors], страница получает список всех моторов, обновляется массив
        с текущими моторами [current_engines], а затем вызывается функция [addNewEngine],
        которая динамически добавляет необходимые блоки на страницу.
    - только в случае успешного ответа от [/motors] и после добавления всех моторов на страницу
        (чтобы не было параллельного добавления моторов данной функции и вебсокета) вызывается
        функция [connect], в которой происходит создание подключения к брокеру, а уже эта функция
        содержит в себе вызов [onConnected], где происходит подписка на тему [/topic/public], куда
        брокер будет публиковать сообщения.

    При загрузке страницы в коде js cоздаются также следующие переменные:
        - [active_motor]:    хранит имя мотора, который в данный момент выделен,
        - [current_engines]: массив с именами(номерами) текущих моторов, нужен для сопоставления
                             с полученными в запросе моторами из БД.
        - [units]:  map, которая хранит пары {"tool":"unit"}, нужна при работе с блоком [select].
        - [snd]:    новый аудио-объект, хранящий ссылку на звуковой файл.
        - [volume]: принимает значение [on], если пользователь включил звук на странице.
        - [login]:  имя пользователя, которое приходит после запроса на [/me].
        - [charts]: map, которая хранит данные о графиках (имена и названия dp), нужна при работе
                    с графиками, из нее можно вытягивать нужный объект с графиком или нужный dp
                    графика по имени конкретного [tool], так как для каждого датчика свой набор
                    графиков (3 живых графика и 3 с последними значениями),
        - 6 объектов с графиками (3 графика с живыми данными и 3 графика с последними значениями),
        - всевозможные функции для работы с данными или с элементами на странице.

    Каждую секунду с сервера приходят сообщения с данными из БД, каждое из которых содержит
 список tools с критическими значениями, список всех моторов, последнее по времени значение
 для каждого датчика каждого из моторов (только если у конкретно датчика мотора есть хотя бы одно
 такое значение), а также временную метку сообщения с сервера. В коде страницы определена функция
 [onMessageReceived], которая вызывается каждый раз, как приходит сообщение с сервера. В ней просходит
 вызов [JSON.parse()] для перевода JSON в объект JS, а после этого вызывается [processingWSData],
 в которую передается данный объект.
 Функция [processingWSData] выполняет следующие действия:
        - сопоставляет моторы из БД и моторы текущие, если есть отличия, добавляет нужные
          и удаляет ненужные со страницы, редактирует массив с текущими моторами,
        - динамически обновляет критические значения в блоке [selectTool], так как они могли быть
          изменены другим пользователем,
        - сохраняет временную отметку сообщения с сервера в переменную [server_ts], данное время
          берется в формате GMT, переводит его в секунды,
        - сохраняет временную метку сообщения с сервера в стринговом формате [00:00:00] в
          переменную [server_time], для использования в качестве label на графиках, данное время
          автоматически конвертируется во время текущего часового пояса,
        - забирает список всех tools,
        - пробегает циклом подряд все моторы: сохраняет номер мотора, а также переменную цвета диода,
          затем в каждом моторе пробегает по всем tools и для каждого из них делает следующее.
            Если данный мотор есть в values и для этого tool есть значение, то сохраняем [temp_value].
            Затем по имени данного tool получаем: график, его dp, ссылку на текстовое поле в блоке с
          мотором, а также критическое значение датчика и его единицы измерения.
            Сравниваем текущее значение и критическое, по результатам устанавливаем переменную цвета,
          выводим в текстовое поле с нужным цветом, и если данный мотор сейчас активен, то отрисовываем
          значение на графике вызовом функции [renderLiveChart].
            После того, как пробежали циклом все tools, смотрим на значение для цвета, и устанавливаем
          диод соответствующего цвета для всего мотора (если есть хоть одно красное значение - red,
          если нет красных, но хоть одно зеленое - green, и если все пустые, то grey).
            Если хотя бы один мотор в данном сообщении 'красный', то есть содержит хоть одно 'красное'
          значение, то переменная [alert] устанавливается в [on]. После того, как цикл пробежал все
          моторы, если переменная [alert] установлена в [on], раздается звуковой сигнал (если на странице
          была нажата кнопка включения звука и тем самым переменная [volume] установлена в [on]).


    При удалении какого-то пользователя под суперадмином сервер, в случае успешного удаления пользователя
из БД, также отправляет сообщение через вебсокет на топик [/topic/logout/<username>] значение [out].
Все страницы, которые подписаны на данный топик с конкретным <username>, при получении сообщения совершат
переход на [/go_away] и разлогинятся.


    Важной является функция нажатия на конкретный мотор, так как при этом:
        - перебираем все ключи из map [charts] (по сути, все tools), и очищаем все графики,
          как живые, так и last values,
        - в зависимости от того, какой элемент активен на момент нажатия, делаем активным необходимый,
          если до этого не был выделен ни один, делаем видимыми блоки с графиками,
        - дополнительно рендерим все графики (особенность библиотеки CanvasJS, необходимо рендерить
          графики только после того, как на странице уже созданы блоки с контейнерами для графиков).

    Функция [getLastValues] для отображения последних n значений на графиках:
        - забираем дельту из выпадающего списка (временной интервал в секундах),
        - для каждого tool делаем запрос на [/last_values] в формате application/form, отправляя
          значение дельты, мотор и tool, и получая обратно значение в формате JSON,
        - по имени данного tool получаем: график, его dp, а также критическое значение датчика,
        - очищаем график и шкалу, так как очистка должна происходить и при каждом новом
          значении диапазона,
        - с сервера нам приходит массив с нужным количеством значений, нам остается только отобразить их
          на странице, поэтому циклом пробегаем все значения, сравниваем значение датчика с критическим
          и отрисовываем на графике.

    Отдельно стоит описать принцип работы модального окна [SET CRITICAL VALUES]:
        - при вызове формы в первую очередь мы очищаем элемент [selectTool] (выпадающий список с
          названиями tools), блокируем его на случай, что сервер с данными не доступен, очищаем
          map [units],
        - делаем запрос на [/tools] и получаем список датчиков и их критических значений,
        - в случае успеха разблокируем выпадающий список и циклом пробегаем по всем tools,
        - для самого первого итерируемого датчика устанавливаем его значение и ЕИ в поле с
          критическим значением, а в выпадающем списке устанавливаем его имя как selected,
        - динамически добавляем в выпадающий список поля [option], которые хранят в качестве
          значения пару [value+unit], а в качестве текста имя самого tool,
        - добавляем в [units] пару [tool-unit].
    При изменении строки в выпадающем списке автоматически поле [critical_value] заполняется
соответствующим значением [value+unit].
    При нажатии на кнопку [SET_CRITICAL] происходит следующее:
        - забираем новое значение из текстового поля,
        - забираем tool из выпадающего списка,
        - делаем запрос на [/change_tool],
        - в случае успеха устанавливаем в свойство текущего элемента в [selectTool] новое значение
          [value+unit],
        - это же значение кидаем в текстовое поле [critica_value],
        - очищаем текстовое поле с новым значанием.

    Обновление [selectTool] раз в секунду происходит следующим образом:
        - если форма открыта в данный момент на странице, достаем список tools и пары объектов [value,unit],
        - пробегаем по всем tools,
        - если option содержит данный tool, то меняем его значение на текущее [value+unit],
        - для выбранного tool в выпадающем списке заменяем и значение в текстовом поле [critical_value].


    3. Security

    Безопасность в приложении работает следующим образом. В БД есть таблица, хранящая данные о пользователях
(имя, фамилия, логин(уникальный), хэш пароля, роль). Для того, чтобы проверить результат попытки залогиниться
и в случае неудачи не перезагружать страницу, а просто показать окно [showAlert], вместо простой функции
[submit] реализована следующая логика:
    - пользователь вводит логин и пароль, осуществляется правильность заполнения
      данных полей, и, если все нормально, идет запрос на [/perform_login],
    - далее на сервере срабатывает один из двух handlers - success или failure,
    - в каждом handler в ответ помещаем JSON с двумя параметрами - [redirect] и [status],
    - затем на странице в ajax-запросе получаем данный JSON и смотрим - в зависимости от
      статуса вручную редиректим на указанную страницу или открываем окно об ошибке.

    В данном приложении используется аутентификация на основе сессий, то есть, объект Authentication
после удачного ввода логина и пароля, в след раз восстанавливается по номеру сессии. Если данный cookie
изменить или удалить, то придется залогиниваться заново. В REST-сервисах используется аутентификация
с использованием токенов, чаще всего вариант с JWT(Java Web Token), и конкретная реализация - OAuth2.
В REST-сервисах не используются сессии, потому что запросить такой сервис может не только браузер,
но и приложение или другой сервис. Токены в таком случае безопаснее всего хранить в БД.

    В момент аутентификации спрингу надо сопоставить логин и пароль, которые пришли со страницы, с логином
и паролем из БД, он вытягивает из БД данные с использованием [UserDetailsServiceImpl], в котором только
одна функция - получить из БД данные о User и создать на основе этих данных объект UserDetails, с которым
уже может работать сам Spring. При помощи [passwordEncoder] сопоставляются логины и хэш паролей, и если
все успешно, возвращается объект Authentication,  но заполненный по-другому. После аутентификации в поле
Principal объекта Authentication будет реальный пользователь в виде UserDetails.
    При этом поле Credentials обнуляется, а isAuthenticated() меняется с false на true. Тогда объект
Authentication сохраняется в SecurityContext, а тот, в свою очередь, — в SecurityContextHolder.
    Аутентификация происходит только раз. Если она прошла успешно, Authentication восстанавливается
из контекста, а в итоге из сессии, при последующих запросах.

    В самом контроллере в момент запроса к нему мы можем вытянуть Authentication из запроса и проверить
нужную нам информацию, к примеру, аутентифицирован ли пользователь, или Authentication равна null, а также
можем проверить роль пользователя.
    Может быть несколько вариантов:
        - если пользователь не аутентифицирован, то любая попытка зайти на страницу,
          будет возвращать его на страницу логина,
        - если пользователь аутентифицировался, приложение перекидывает его на [/main],
          а та в свою очередь проверяет роль пользователя, и, если это ADMIN, отдает
          ему страницу для админа, если USER, то страницу для пользователя.
    Выход и обнуление Authentication происходит при запросе на [/go_away]. После этого ассоциация данной
сессии с конкретным Authentication пропадает, и необходимо будет залогиниться еще раз.

    Отдельно нужно упомянуть CORS и защиту от CSRF-атак, а также то, как безопасно выполнять запросы
к серверу (к примеру, советуют отправлять данные на сервер в виде JSON (contentType: "application/json")
и отправлять запросы на получение данных тоже через POST, а не через GET-запросы).

    - CORS (Cross-Origin Resource Sharing)
        Это технология, которая запрещает браузеру обращаться к другому сайту без специального
      разрешения. Таким разрешением служит заголовок Access-Control-Allow-Origin. Браузер
      не будет показывать ответ от сервера, а выбросит ошибку, если увидит, что [Host] (куда)
      и [Origin] (откуда) отличаются, а заголовка, указывающего, каким сайтам разрешено делать
      запрос к серверу, нет.
        Для разрешения проблемы, на сервере нужно включить CORS, а также указать, каким доменам
      разрешено обращаться к серверу, а также какие разрешены методы, после этого в ответ сервера
      будут добавляться соответствующие заголовки.
        Подробнее о CORS здесь(https://sysout.ru/nastrojka-cors-v-spring-security/).
        Важно понимать, что даже если мы выключим CORS(по умолчанию в Sring Security) и запретим
      кросс-доменные запросы, браузер заблокирует не запрос, а ответ. Это значит, что в определенных
      ситуациях POST-запрос может пройти, отправить куки и изменить данные, но ответ будет заблокирован
      браузером. Как избежать этого, описано ниже.

    - CSRF (Сross-Site Request Forgery)
        Подробнее о сути CSRF-атак можно почитать здесь (https://sysout.ru/csrf-token/).
        Есть запросы, которые отправляются сразу, без предварительного запроса, так называемые simple requests.
      Это GET, HEAD, POST с определенным Content-Type. В частности, POST-запросы  с формы. Такой запрос
      сразу идет в контроллер. А учитывая, что куки браузер отправляет автоматически, запрос попадет в
      защищенный контроллер и выполнит действие на банковском сайте. Хотя ответ получить и распарсить нельзя,
      действие  будет выполнено.
        Защититься от этого можно, добавив на страницу CSRF-токен. Он добавляется сервером в момент сборки
      страницы (при использовании [jsp] или [thymeleaf]) либо в скрытое поле [input], либо в заголовок.
      Токен должен отправляться как скрытое поле со всех форм (также он должен прилагаться в
      XMLHttpRequest-запросах PUT, DELETE, POST — это для JavaScript). Этот способ самый верный.
        Но есть и другие способы защититься от подобных атак, не используя токен. Разумеется, CORS должен
      быть изначально настроен только на доверенные сайты. Так как подобные атаки могут осуществляться
      только из браузера самого же пользователя, потому что с запросом на сайте мошенников должны
      отправиться куки, которые хранятся в браузере самого пользователя, то для обращения к нашему сайту
      мы можем использовать сложные запросы, к примеру POST-запрос, но уже с Content-Type
      не [application/form] или [text/plain], а с [application/json]. В этом случае браузер отправляет
      предварительно "preflight" запрос перед основным запросом. И если этот запрос не вернул ответ с
      необходимым заголовком Access-Control-Allow-Origin, то второй запрос выполняться не будет.
      Но важно учесть, что на сервере в контроллере необходимо прописать, что он принимает только
      "application/json" запросы (в спринге это делается добавлением [consumes = "application/json"])
        Таким образом, используя JSON, мы можем перестраховаться от того, что запрос пришел не с того домена,
      предварительно проверив источник. В таком случае, POST-запрос не сможет даже выполниться на сервере.
      Однако надо быть уверенным, что в случае сложного запроса браузер точно отправит предварительный
      запрос.

    В данном приложении используются следующие степени защиты доступа:
        -  в первую очередь, защита приложения паролем (на основе сессии, без использования токенов), что
           защищает конечные точки сервера от доступа злоумышленников,
        -  здесь не используется CSRF-токен, но при необходимости может использоваться либо он, либо
           сложные запросы (POST-запросы с JSON) для изменения данных (сложные запросы вместе с запретом
           CORS могли бы дать хорошую защиту от CSRF-атак)
        -  выключен CORS, то есть запрещены кросс-доменные запросы с других сайтов в браузере, но в данной
           ситуации они и так будут недоступны, так как эндпоинт будет недоступен без аутентификации.

    Отдельно надо упомянуть про  Spring Security для Websocket:

        - специфичная для WebSocket безопасность с использованием библиотеки [spring security-messaging]
          сосредоточена на классе [AbstractSecurityWebSocketMessageBrokerConfigurer] и его реализации в
          проекте. [AbstractSecurityWebSocketMessageBrokerConfigurer] класс обеспечивает дополнительное
          покрытие безопасности к предоставляемой [WebSecurityConfigurerAdapter].
            Реализация [configureInbound()] является наиболее важным шагом в настройке специфичной для
          вебсокета безопасности. В то время как WebSecurityConfigurerAdapter позволяет указать различные
          требования к авторизации в масштабе приложения для разных маршрутов,
          AbstractSecurityWebSocketMessageBrokerConfigurer позволяет указать конкретные требования
          авторизации для мест назначения сокетов.
            [MessageSecurityMetadataSourceRegistry] позволяет нам указывать ограничения безопасности,
          для конкретных путей (подписок и отправки сообщений), ролей пользователей, а также типов
          разрешенных событий. Например:
            - [.simpTypeMatchers(CONNECT, UNSUBSCRIBE, DISCONNECT).permitAll()] - разрешить всем
              пользователям конкретные типы сообщений
            - [.simpDestMatchers("/app/**").hasRole("ADMIN")] - разрешить конечную точку только для
              пользователей с ролью [admin]
            - [.simpSubscribeDestMatchers("/topic/**").authenticated()] - разрешить сообщения типа
              SUBSCRIBE (подписку на конкретный эндпоинт) только для аутентифицированных клиентов.

        - по умолчанию для сообщений через вебсокет действует политика одного источника, она требует,
          чтобы все взаимодействия с конечной точкой происходили из того же домена, в котором
          взаимодействие было инициировано. По дефолту Spring Security требует токен CSRF  для любого
          допустимого сообщения типа [CONNECT]. Есть два способа это изменить:
            - использовать CSRF-токены,
            - отключить проверку, указав в реализации метода [sameOriginDisabled()] [true].

        - клиент SockJS начинает с отправки, [GET /info] на эндпоинт для подключения (в нашем случае [/ws]),
          чтобы получить основную информацию от сервера. После этого он должен решить, какой транспорт
          использовать.  Если возможно, используется WebSocket. После этого отправляет запрос-рукопожатие на
          [ws://localhost/ws/...]. Для этого эндпоинта Spring Security дополнительно устанавливает запрет CORS,
          даже есть в основной конфигурации Security CORS разрешен для всех источников,
          а также [sameOriginDisabled()] в настройках WebSocket Security установлен в [true].
          Таким образом, уже GET-запрос не вернет ответ, а значит, SockJS оборвет подключение и не станет
          отправлять рукопожатие на .
          Чтобы этого не случилось, нужно также разрешить определенные Origins для endpoint [/ws].
          Делается это путем добавления к описанию эндпоинта свойства [setAllowedOrigins()]. Таким образом,
          http-запрос на [/ws/info] пройдет из лобого указанного вручную источника, клиент отправит рукопожатие
          на [ws://localhost/ws/...], которое тоже пройдет, а затем отправит CONNECT.